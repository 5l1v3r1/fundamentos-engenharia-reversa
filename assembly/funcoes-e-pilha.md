# Fun√ß√µes e pilha

Apesar de n√£o estudarmos todos os aspectos da linguagem Assembly, alguns assuntos s√£o de extrema import√¢ncia, mesmo para os fundamentos da engenharia reversa de software. Um deles √© como funcionam as fun√ß√µes criadas em um programa e suas chamadas, que discutiremos agora.

## O que √© uma fun√ß√£o?

Basicamente, uma fun√ß√£o √© um **bloco de c√≥digo reutiliz√°vel** num programa. Tal bloco faz-se √∫til quando um determinado conjunto de instru√ß√µes precisa ser invocado em v√°rios pontos do programa. Por exemplo, suponha um programa que precise converter a temperatura de Fahrenheit para Celsius v√°rias vezes no decorrer de seu c√≥digo:

{% code-tabs %}
{% code-tabs-item title="fahrenheit2celsius.py" %}
```python
fahrenheit = 230.4
celsius = (fahrenheit - 32) * 5 / 9
print(celsius)

fahrenheit = 130.3
celsius = (fahrenheit - 32) * 5 / 9
print(celsius)

fahrenheit = 90.1
celsius = (fahrenheit - 32) * 5 / 9
print(celsius)
```
{% endcode-tabs-item %}
{% endcode-tabs %}

O programa acima funciona e a sa√≠da √©, conforme esperada:

```text
110.22222222222223
54.611111111111114
32.27777777777778
```

No entanto, √© pouco pr√°tico, pois repetimos o mesmo c√≥digo v√°rias vezes. Al√©m disso, uma vers√£o compilada fica maior em _bytes_. Tamb√©m prejudica a manuten√ß√£o do c√≥digo pois se o programador precisar fazer uma altera√ß√£o no c√°lculo, vai ter que alterar em todos eles. √â a√≠ que entram as fun√ß√µes. Veja:

{% code-tabs %}
{% code-tabs-item title="fahrenheit2celsius.py" %}
```python
def fahrenheit2celsius(fahrenheit):
    return (fahrenheit - 32) * 5 / 9

celsius = fahrenheit2celsius(230.4)
print(celsius)

celsius = fahrenheit2celsius(130.3)
print(celsius)

celsius = fahrenheit2celsius(90.1)
print(celsius)
```
{% endcode-tabs-item %}
{% endcode-tabs %}

A sa√≠da √© a mesma, mas agora o programa est√° utilizando uma fun√ß√£o, onde o c√°lculo s√≥ foi definido uma √∫nica vez e toda vez que for necess√°rio, o programa a chama.

Uma fun√ß√£o tem:

1. Argumentos, tamb√©m chamados de par√¢metros, que s√£o os dados que a fun√ß√£o recebe, necess√°rios para cumprir seu prop√≥sito.
2. Retorno, que √© o resultado da conclus√£o do seu prop√≥sito, seja bem sucedida ou n√£o.
3. Um nome \(na vis√£o do programador\) ou um endere√ßo de mem√≥ria \(na vis√£o do processador\).

Agora cabe a n√≥s estudar como isso tudo funciona em baixo n√≠vel. Pronto? ü§∑‚Äç‚ôÇÔ∏è

{% hint style="info" %}
Nos prim√≥rdios da computa√ß√£o as fun√ß√µes eram chamadas de **procedimentos** \(_procedures_\). Em algumas linguagens de programa√ß√£o, no entanto, possuem tanto fun√ß√µes quanto procedimentos. Estes √∫ltimos s√£o "fun√ß√µes que n√£o retornam nada". J√° no paradigma da programa√ß√£o orientada a objetos \(POO\), as fun√ß√µes de uma classe s√£o chamadas de **m√©todos**.
{% endhint %}

## Fun√ß√µes em Assembly

Em baixo n√≠vel, uma fun√ß√£o √© implementada basicamente num bloco que n√£o ser√° executado at√© ser chamado por uma instru√ß√£o CALL. Ao final de uma instru√ß√£o, encontramos normalmente a instru√ß√£o RET. Vamos analisar uma fun√ß√£o simples de soma para entender:

```c
#include <stdio.h>

int soma(int x, int y) {
  return x+y;
}

int main(void) {
  printf("%d\n", soma(3,4));
  return 0;
}
```

Olha como ela fica compilada no Linux em 32-bits:

```text
0804840b <soma>:
 804840b:       55                      push   ebp
 804840c:       89 e5                   mov    ebp,esp
 804840e:       8b 55 08                mov    edx,DWORD PTR [ebp+0x8]
 8048411:       8b 45 0c                mov    eax,DWORD PTR [ebp+0xc]
 8048414:       01 d0                   add    eax,edx
 8048416:       5d                      pop    ebp
 8048417:       c3                      ret

08048418 <main>:
...
 8048429:       6a 04                   push   0x4
 804842b:       6a 03                   push   0x3
 804842d:       e8 d9 ff ff ff          call   804840b <soma>
 8048432:       83 c4 08                add    esp,0x8
```

Removi partes do c√≥digo intencionalmente, pois o objetivo neste momento √© apresentar as instru√ß√µes que implementam as chamadas de fun√ß√£o. Por hora, voc√™ s√≥ precisa entender que a instru√ß√£o CALL \(no endere√ßo 0x804842d em nosso exemplo\) chama as fun√ß√µes e a instru√ß√£o RET \(em 0x8048417\) retorna para a instru√ß√£o imediatamente ap√≥s a CALL \(0x8048432\), para que a execu√ß√£o continue.

### A pilha de mem√≥ria

A mem√≥ria RAM para um processo √© dividida em √°reas com diferentes prop√≥sitos. Uma delas √© a pilha, ou _stack_.

Essa √°rea de mem√≥ria funciona de forma com que o que √© colocado l√° fique no topo e o √∫ltimo dado colocado na pilha seja o primeiro a ser retirado, como uma pilha de pratos ou de cartas de baralho. Esse m√©todo √© conhecido por LIFO \(_Last In First Out_\).

Seu principal uso √© no uso de fun√ß√µes, tanto para passagem de argumentos \(par√¢metros da fun√ß√£o\) quanto para aloca√ß√£o de vari√°veis locais √† fun√ß√£o \(que s√≥ existem enquanto a fun√ß√£o executa\).

Na IA-32, a pilha √© alinhada em 4 _bytes_ \(32-bits\). Por consequ√™ncia todos os seus endere√ßos tamb√©m o s√£o. Logo, se novos dados s√£o colocados na pilha \(empilhados\), o endere√ßo do topo √© **decrementado** em 4 unidades. Se um dado for desempilhado, o endere√ßo √© **incrementado** em 4 unidades. Perceba a l√≥gica invertida, porque a pilha come√ßa num endere√ßo alto e vai descendo.

Existem dois registradores intimamente associados com a pilha de mem√≥ria alocada para um processo. S√£o eles:

* O ESP, que aponta para o topo da pilha.
* O EBP, que aponta para a base do _stack frame_.

A instru√ß√£o CALL faz duas coisas:

1. Coloca o endere√ßo da pr√≥xima instru√ß√£o na pilha de mem√≥ria \(no caso do exemplo, 0x8048432\).
2. Coloca o seu par√¢metro, ou seja, o endere√ßo da fun√ß√£o a ser chamada, no registrador EIP \(no exemplo √© o endere√ßo 0x804840b\).

Por conta dessa atualiza√ß√£o do EIP, o fluxo √© desviado para o endere√ßo da fun√ß√£o chamada. A ideia de colocar o endere√ßo da pr√≥xima instru√ß√£o na pilha √© para o processador saber para onde tem que voltar quando a fun√ß√£o terminar. E falando em terminar, a estrela do fim da festa √© a instru√ß√£o RET \(de _RETURN_\). Ela faz uma √∫nica coisa:

1. Retira um valor do topo da pilha e coloca no EIP.

{% hint style="danger" %}
AINDA ESTAMOS TRABALHANDO NESTA SE√á√ÉO
{% endhint %}



* O principal uso da pilha \(stack\) eÃÅ para as funcÃßoÃÉes armazenarem variaÃÅveis locais e tambeÃÅm para passagem de paraÃÇmetros \(dependendo da calling convention\).
* Alinhas em 4 bytes \(32-bits\)
  * Cresce para baixo
  * ProÃÅlogo e epiÃÅlogo de funcÃßoÃÉes
* RecuperacÃßaÃÉo de paraÃÇmetros
* InstrucÃßoÃÉes de manipulacÃßaÃÉo da pilha:
  * PUSH copia um valor para a pilha \(empilha\) e decremente o registrador ESP em 4. Ex.: PUSH 0x51
  * POP recupera um valor da pilha \(desempilha\) para algum lugar e incrementa ESP em 4. Exemplo: POP EBX.
  * CALL empilha o enderecÃßo da proÃÅxima instrucÃßaÃÉo e muda o EIP para o destino dela.
  * RET desempilha o enderecÃßo no topo da pilha para EIP

